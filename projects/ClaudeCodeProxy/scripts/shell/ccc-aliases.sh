# shellcheck shell=sh

if [ -z "${CCC_REPO_ROOT:-}" ]; then
  printf '%s\n' "[ccc] CCC_REPO_ROOT is not set; export it before sourcing ccc-aliases.sh" >&2
  (return 1 2>/dev/null) || exit 1
fi

CCC_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ccc"
CCC_ENV_FILE="${CCC_CONFIG_DIR}/env"
CCC_PID_FILE="${CCC_CONFIG_DIR}/shim.pid"

ccc__ensure_dirs() {
  mkdir -p "$CCC_CONFIG_DIR"
}

ccc__escape() {
  value=$1
  printf '%s' "$value" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

ccc__write_export_line() {
  name=$1
  value=$2
  escaped=$(ccc__escape "$value")
  printf 'export %s="%s"\n' "$name" "$escaped"
}

ccc__write_env_on() {
  env_port=$1
  env_log_dir=$2
  env_results_dir=$3
  env_license_dir=$4
  ccc__ensure_dirs
  {
    printf '# Auto-generated by ccc-on; edit with care.\n'
    ccc__write_export_line "CLAUDE_CODE_SUBAGENT_MODEL" "haiku"
    ccc__write_export_line "ANTHROPIC_BASE_URL" "http://127.0.0.1:${env_port}"
    printf 'unset HTTPS_PROXY\n'
    printf 'unset NODE_EXTRA_CA_CERTS\n'
    printf 'unset ANTHROPIC_AUTH_TOKEN\n'
    ccc__write_export_line "CCP_PROFILE" "${CCP_PROFILE:-prod}"
    ccc__write_export_line "CCP_PORT_DEFAULT" "$env_port"
    ccc__write_export_line "CCP_LOGS_DIR" "$env_log_dir"
    ccc__write_export_line "CCP_RESULTS_DIR" "$env_results_dir"
    ccc__write_export_line "CCP_LICENSE_DIR" "$env_license_dir"
  } > "$CCC_ENV_FILE"
}

ccc__write_env_off() {
  env_port=$1
  env_log_dir=$2
  env_results_dir=$3
  env_license_dir=$4
  ccc__ensure_dirs
  {
    printf '# Auto-generated by ccc-off; proxy disabled.\n'
    printf 'unset ANTHROPIC_BASE_URL\n'
    printf 'unset HTTPS_PROXY\n'
    printf 'unset NODE_EXTRA_CA_CERTS\n'
    printf 'unset ANTHROPIC_AUTH_TOKEN\n'
    printf 'unset CLAUDE_CODE_SUBAGENT_MODEL\n'
    ccc__write_export_line "CCP_PROFILE" "${CCP_PROFILE:-prod}"
    ccc__write_export_line "CCP_PORT_DEFAULT" "$env_port"
    ccc__write_export_line "CCP_LOGS_DIR" "$env_log_dir"
    ccc__write_export_line "CCP_RESULTS_DIR" "$env_results_dir"
    ccc__write_export_line "CCP_LICENSE_DIR" "$env_license_dir"
  } > "$CCC_ENV_FILE"
}

ccc__apply_env_file() {
  if [ -f "$CCC_ENV_FILE" ]; then
    # shellcheck disable=SC1090
    . "$CCC_ENV_FILE"
  fi
}

ccc_on() {
  port="${1:-${CCP_PORT_DEFAULT:-8082}}"
  profile="${CCP_PROFILE:-prod}"
  log_dir="${CCP_LOGS_DIR:-${CCC_REPO_ROOT}/logs/${profile}}"
  results_dir="${CCP_RESULTS_DIR:-${CCC_REPO_ROOT}/results/${profile}}"
  license_dir="${CCP_LICENSE_DIR:-${XDG_CONFIG_HOME:-$HOME/.config}/ccp}"

  mkdir -p "$log_dir" "$results_dir" "$license_dir"
  ccc__ensure_dirs

  CCP_PROFILE="$profile"
  CCP_PORT_DEFAULT="$port"
  CCP_LOGS_DIR="$log_dir"
  CCP_RESULTS_DIR="$results_dir"
  CCP_LICENSE_DIR="$license_dir"
  CLAUDE_CODE_SUBAGENT_MODEL="haiku"
  export CCP_PROFILE CCP_PORT_DEFAULT CCP_LOGS_DIR CCP_RESULTS_DIR CCP_LICENSE_DIR CLAUDE_CODE_SUBAGENT_MODEL

  CCP_LOGS_DIR="$log_dir" "$CCC_REPO_ROOT/scripts/run-go-shim.sh" "$port" || {
    # Build/start failed. Try to show recent shim output if present.
    if [ -f "$log_dir/ccp.out" ]; then
      printf '%s\n' '--- tail ccp.out ---' >&2
      tail -n 80 "$log_dir/ccp.out" >&2 || true
    fi
    return 1
  }

  # Health-gate before declaring proxy ON
  ok=0
  for i in 1 2 3 4 5; do
    sleep 1
    if curl -sSf "http://127.0.0.1:${port}/healthz" >/dev/null 2>&1; then ok=1; break; fi
  done
  if [ "$ok" -ne 1 ]; then
    printf '%s\n' "[ccc] shim not healthy on :${port}" >&2
    if [ -f "$log_dir/ccp.out" ]; then
      printf '%s\n' '--- tail ccp.out ---' >&2
      tail -n 80 "$log_dir/ccp.out" >&2 || true
    fi
    return 1
  fi

  if [ -f "$log_dir/ccp.pid" ]; then
    cp "$log_dir/ccp.pid" "$CCC_PID_FILE" 2>/dev/null || true
  fi

  ccc__write_env_on "$port" "$log_dir" "$results_dir" "$license_dir"
  ccc__apply_env_file

  "$CCC_REPO_ROOT/bin/cc" usage --banner >/dev/null 2>&1 || true

  if ! command -v claude >/dev/null 2>&1; then
    printf '%s\n' "[ccc] warning: claude CLI not found in PATH" >&2
  fi

  printf '[ccc] proxy ON (port %s)\n' "$port"
}

ccc_off() {
  quiet=0
  if [ "${1:-}" = "--quiet" ]; then
    quiet=1
    shift
  fi

  if [ -f "$CCC_PID_FILE" ]; then
    pid=$(cat "$CCC_PID_FILE")
    if [ -n "$pid" ] && kill -0 "$pid" >/dev/null 2>&1; then
      kill "$pid" >/dev/null 2>&1 || true
    fi
    rm -f "$CCC_PID_FILE"
  fi

  off_log_dir="${CCP_LOGS_DIR:-${CCC_REPO_ROOT}/logs/${CCP_PROFILE:-prod}}"
  off_results_dir="${CCP_RESULTS_DIR:-${CCC_REPO_ROOT}/results/${CCP_PROFILE:-prod}}"
  off_license_dir="${CCP_LICENSE_DIR:-${XDG_CONFIG_HOME:-$HOME/.config}/ccp}"

  rm -f "$off_log_dir/ccp.pid"
  pkill -f 'services/go-anth-shim/bin/ccp' >/dev/null 2>&1 || true

  off_port="${CCP_PORT_DEFAULT:-8082}"
  ccc__write_env_off "$off_port" "$off_log_dir" "$off_results_dir" "$off_license_dir"
  ccc__apply_env_file

  if [ "$quiet" -ne 1 ]; then
    printf '%s\n' "[ccc] proxy OFF"
  fi
}

ccc_restart() {
  port="${1:-${CCP_PORT_DEFAULT:-8082}}"
  profile="${CCP_PROFILE:-prod}"
  log_dir="${CCP_LOGS_DIR:-${CCC_REPO_ROOT}/logs/${profile}}"
  ccc_off --quiet
  if ! ccc_on "$port"; then
    # ccc_on already tried to show ccp.out; ensure non-zero exit
    return 1
  fi
}

ccc_status() {
  printf '%s\n' '--- current shell ---'
  env | grep -E '^CCP_|^ANTHROPIC_BASE_URL|^CLAUDE_CODE_SUBAGENT_MODEL' | sort || true
  printf '%s\n' '--- env file ---'
  if [ -f "$CCC_ENV_FILE" ]; then
    cat "$CCC_ENV_FILE"
  else
    printf '[ccc] no env file at %s\n' "$CCC_ENV_FILE"
  fi
  printf '%s\n' '--- shim ---'
  if [ -f "$CCC_PID_FILE" ]; then
    pid=$(cat "$CCC_PID_FILE")
    if [ -n "$pid" ] && kill -0 "$pid" >/dev/null 2>&1; then
      printf '[ccc] shim running (pid %s)\n' "$pid"
    else
      printf '[ccc] shim pid file stale (pid %s)\n' "$pid"
    fi
  else
    printf '%s\n' '[ccc] shim not running'
  fi
  port="${CCP_PORT_DEFAULT:-8082}"
  profile="${CCP_PROFILE:-prod}"
  printf '[ccc] profile=%s port=%s\n' "$profile" "$port"
  if command -v lsof >/dev/null 2>&1; then
    lsof -iTCP:"$port" -sTCP:LISTEN -n -P 2>/dev/null | grep 'ccp' || true
  fi
  if command -v curl >/dev/null 2>&1; then
    if curl --max-time 2 -sSf "http://127.0.0.1:${port}/healthz" >/dev/null 2>&1; then
      printf '%s\n' '[ccc] healthz=ok'
    else
      printf '%s\n' '[ccc] healthz=unavailable'
    fi
  fi
}

ccc_logs() {
  profile="${CCP_PROFILE:-prod}"
  log_root="${CCP_LOGS_DIR:-${CCC_REPO_ROOT}/logs/${profile}}"
  log_file="${log_root}/usage.jsonl"
  mkdir -p "$log_root"
  [ -e "$log_file" ] || : > "$log_file"
  printf '[ccc] tailing %s (Ctrl-C to stop)\n' "$log_file"
  tail -F "$log_file"
}

ccc_start() {
  ccc_on "$@"
}

ccc_env() {
  if [ $# -gt 0 ]; then
    ccc_on "$1"
    return $?
  fi
  if [ -f "$CCC_ENV_FILE" ]; then
    ccc__apply_env_file
    printf '[ccc-env] sourced %s\n' "$CCC_ENV_FILE"
    return 0
  fi
  printf '%s\n' '[ccc-env] env file not found; run ccc-on first' >&2
  return 1
}

ccc_stop() {
  ccc_off "$@"
}

ccc_haiku()  { claude -p --model haiku  "$@"; }
ccc_sonnet() { claude -p --model sonnet "$@"; }
ccc_license(){ "$CCC_REPO_ROOT/bin/cc" license status "$@"; }

ccc_mitm()    { MITM_FILTER_CHAIN=1 MITM_PORT="${1:-8082}" FORCE_HAIKU_TO_ZAI=1 make -C "$CCC_REPO_ROOT" mitm; }
# shellcheck disable=SC1091
ccc_sub()     { MITM_PORT="${1:-8082}" . "$CCC_REPO_ROOT/scripts/sub-env.sh" && export CLAUDE_CODE_SUBAGENT_MODEL=haiku; }
ccc_mitmstop(){ pkill -f "mitmdump.*-p ${1:-8082}" >/dev/null 2>&1 || true; }

ccc_verify()  { (cd "$CCC_REPO_ROOT" && make summarize && make verify-routing); }
ccc_bundle()  { make -C "$CCC_REPO_ROOT" bundle; }

ccc_stock()   { unset HTTPS_PROXY NODE_EXTRA_CA_CERTS ANTHROPIC_BASE_URL ANTHROPIC_AUTH_TOKEN CLAUDE_CODE_SUBAGENT_MODEL; printf '%s\n' "[stock] unproxied"; claude; }
ccc_zai()     { export ANTHROPIC_BASE_URL="https://api.z.ai/api/anthropic"; export ANTHROPIC_AUTH_TOKEN="${ZAI_API_KEY:-}"; printf '%s\n' "[zai-direct] set"; claude; }

alias ccc-on='ccc_on'
alias ccc-off='ccc_off'
alias ccc-status='ccc_status'
alias ccc-logs='ccc_logs'
alias ccc-restart='ccc_restart'

alias ccp-start='ccc_start'
alias ccp-env='ccc_env'
alias ccp-logs='ccc_logs'

# --- Convenience: interactive Haiku session in the current directory ---
# Usage: ccc-haiku-i [PORT]
ccc_haiku_i() {
  port="${1:-${CCP_PORT_DEFAULT:-8082}}"
  case "$port" in
    *[!0-9]*) port="${CCP_PORT_DEFAULT:-8082}" ;;
  esac
  if [ -f "$CCC_REPO_ROOT/scripts/go-env.sh" ]; then
    # shellcheck disable=SC1090
    . "$CCC_REPO_ROOT/scripts/go-env.sh" "$port"
  fi
  mkdir -p "$HOME/.claude/debug"
  printf '[ccc] interactive Haiku in %s (port %s)\n' "$PWD" "$port"
  claude --model "claude-haiku-4-5-20251001"
}

alias ccc-haiku-i='ccc_haiku_i'

# Interactive Sonnet (current directory)
ccc_sonnet_i() {
  port="${1:-${CCP_PORT_DEFAULT:-8082}}"
  case "$port" in
    *[!0-9]*) port="${CCP_PORT_DEFAULT:-8082}" ;;
  esac
  if [ -f "$CCC_REPO_ROOT/scripts/go-env.sh" ]; then
    # shellcheck disable=SC1090
    . "$CCC_REPO_ROOT/scripts/go-env.sh" "$port"
  fi
  mkdir -p "$HOME/.claude/debug"
  printf '[ccc] interactive Sonnet in %s (port %s)\n' "$PWD" "$port"
  claude --model "claude-sonnet-4-5-20250929"
}

alias ccc-sonnet-i='ccc_sonnet_i'

# Health and logs
ccc_health() { curl --max-time 3 -sS "http://127.0.0.1:${1:-${CCP_PORT_DEFAULT:-8082}}/healthz"; printf '\n'; }
alias ccc-health='ccc_health'
alias ccc-out-logs='sh -c "$CCC_REPO_ROOT/scripts/quick/shim-out-tail.sh"'

# Startup on login (LaunchAgent)
ccc_startup_enable() {
  sh "$CCC_REPO_ROOT/scripts/launch/enable.sh" "${1:-${CCP_PORT_DEFAULT:-8082}}"
}
ccc_startup_disable() {
  sh "$CCC_REPO_ROOT/scripts/launch/disable.sh"
}
alias ccc-startup-enable='ccc_startup_enable'
alias ccc-startup-disable='ccc_startup_disable'

# Quick verification: probe both lanes and print recent log lines
ccc_ok() {
  base="${ANTHROPIC_BASE_URL:-http://127.0.0.1:${CCP_PORT_DEFAULT:-8082}}"
  timeout 30 env ANTHROPIC_BASE_URL="$base" claude -p --model "claude-haiku-4-5-20251001" "ok" --output-format json >/dev/null 2>&1 || true
  timeout 30 env ANTHROPIC_BASE_URL="$base" claude -p --model "claude-sonnet-4-5-20250929" "ok" --output-format json >/dev/null 2>&1 || true
  profile="${CCP_PROFILE:-prod}"
  log_root="${CCP_LOGS_DIR:-${CCC_REPO_ROOT}/logs/${profile}}"
  log_file="${log_root}/usage.jsonl"
  printf '%s\n' '--- last Haiku and Sonnet entries ---'
  if command -v rg >/dev/null 2>&1; then
    rg -n '"model":"claude-haiku-4-5-20251001"|"model":"claude-sonnet-4-5-20250929"' "$log_file" | tail -n 6
  else
    grep -n '"model":"claude-haiku-4-5-20251001"\|"model":"claude-sonnet-4-5-20250929"' "$log_file" | tail -n 6
  fi
}
alias ccc-ok='ccc_ok'

# Bootstrap: install aliases, load license, start proxy, verify, print log proof
ccc_bootstrap() {
  sh "$CCC_REPO_ROOT/scripts/quick/bootstrap.sh" "${1:-${CCP_PORT_DEFAULT:-8082}}"
}
alias ccc-bootstrap='ccc_bootstrap'

# Unified interactive launcher (short: cz)
# Usage:
#   cz                 # interactive, no preset model (use /model inside)
#   cz haiku [PORT]    # start with Haiku
#   cz sonnet [PORT]   # start with Sonnet
#   cz <full-model>    # start with provided full model id
cz() {
  model="${1:-}"
  port="${2:-${CCP_PORT_DEFAULT:-8082}}"
  case "$port" in *[!0-9]*) port="${CCP_PORT_DEFAULT:-8082}" ;; esac
  if [ -f "$CCC_REPO_ROOT/scripts/go-env.sh" ]; then
    # shellcheck disable=SC1090
    . "$CCC_REPO_ROOT/scripts/go-env.sh" "$port"
  fi
  mkdir -p "$HOME/.claude/debug"
  # map short names
  if [ -n "$model" ]; then
    case "$model" in
      h|haiku|Haiku)
        model="claude-haiku-4-5-20251001" ;;
      s|sonnet|Sonnet|c)
        model="claude-sonnet-4-5-20250929" ;;
      *) : ;;
    esac
    printf '[ccc] interactive (%s) in %s (port %s)\n' "$model" "$PWD" "$port"
    claude --model "$model"
  else
    printf '[ccc] interactive (no preset model) in %s (port %s)\n' "$PWD" "$port"
    claude
  fi
}
alias ccc-here='cz'

# Switch this shell to stock Anthropic and resume last conversation
# Usage: cz-off  (unsets proxy envs, runs `claude -c` in current dir)
cz_off() {
  unset ANTHROPIC_BASE_URL
  unset HTTPS_PROXY
  unset NODE_EXTRA_CA_CERTS
  unset ANTHROPIC_AUTH_TOKEN
  printf '[ccc] stock mode in %s; resuming last conversation (claude -c)\n' "$PWD"
  claude -c
}
alias cz-off='cz_off'

# Start shim if needed, wait for health, set env, then run cz in current dir
# Usage: cz-up [PORT]
cz_up() {
  port="${1:-${CCP_PORT_DEFAULT:-8082}}"
  # Try health
  if ! curl -sSf "http://127.0.0.1:${port}/healthz" >/dev/null 2>&1; then
    # Start shim on port
    sh "$CCC_REPO_ROOT/scripts/run-go-shim.sh" "$port" >/dev/null 2>&1 || true
    # Wait up to 5 seconds for health
    for i in 1 2 3 4 5; do
      sleep 1
      if curl -sSf "http://127.0.0.1:${port}/healthz" >/dev/null 2>&1; then break; fi
    done
  fi
  if ! curl -sSf "http://127.0.0.1:${port}/healthz" >/dev/null 2>&1; then
    printf '%s\n' "[ccc] shim not healthy on :${port}; try 'ccc-restart ${port}' or use 'cz-off'" >&2
    return 1
  fi
  # Point this shell at shim and run cz
  # shellcheck disable=SC1090
  . "$CCC_REPO_ROOT/scripts/go-env.sh" "$port"
  cz
}
alias cz-up='cz_up'
alias ccp-stop='ccc_stop'
alias ccp-status='ccc_status'
alias ccp-haiku='ccc_haiku'
alias ccp-sonnet='ccc_sonnet'
alias ccp-license='ccc_license'

alias ccgo='ccc_start'
alias ccgoenv='ccc_env'
alias ccgostop='ccc_stop'

alias ccmitm='ccc_mitm'
alias ccsub='ccc_sub'
alias ccmitmstop='ccc_mitmstop'

alias cclogs='ccc_logs'
alias ccverify='ccc_verify'
alias ccbundle='ccc_bundle'
alias ccstock='ccc_stock'
alias cczai='ccc_zai'
