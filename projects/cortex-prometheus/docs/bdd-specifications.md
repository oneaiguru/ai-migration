# BDD-спецификации реализации Prometheus с Cortex

## Функциональность: Установка и базовая настройка

### Сценарий: Установка системы мониторинга на Docker
**Дано:** Сервер с установленным Docker и Docker Compose  
**Когда:** Запускается скрипт `setup_monitoring.sh`  
**Тогда:** Все компоненты системы успешно устанавливаются  
**И:** Все сервисы запускаются без ошибок  
**И:** Prometheus, Cortex, Grafana и AlertManager доступны по HTTP

### Сценарий: Установка системы мониторинга на Kubernetes
**Дано:** Кластер Kubernetes с настроенным kubectl  
**Когда:** Применяются все манифесты из директории kubernetes  
**Тогда:** Все поды успешно создаются и переходят в состояние Running  
**И:** Все сервисы доступны внутри кластера  
**И:** Созданы все необходимые ConfigMap и PVC

### Сценарий: Установка Node Exporter на целевой хост
**Дано:** Целевой хост с доступом по SSH и правами sudo  
**Когда:** Запускается скрипт `install_node_exporter.sh`  
**Тогда:** Node Exporter успешно устанавливается  
**И:** Сервис Node Exporter запускается и добавляется в автозагрузку  
**И:** Метрики доступны по адресу http://host:9100/metrics

## Функциональность: Сбор метрик

### Сценарий: Prometheus собирает метрики со всех хостов
**Дано:** Настроенный Prometheus и хосты с работающим Node Exporter  
**Когда:** Проходит время, больше интервала сбора (scrape_interval)  
**Тогда:** На странице Target в Prometheus все хосты отображаются со статусом "UP"  
**И:** Метрики node_* доступны через интерфейс Prometheus  
**И:** Метрика up == 1 для всех хостов

### Сценарий: Prometheus собирает метрики о себе и других компонентах
**Дано:** Настроенный Prometheus с job_name для компонентов системы  
**Когда:** Prometheus выполняет скрейпинг собственных метрик и метрик Cortex  
**Тогда:** Метрики prometheus_* доступны в интерфейсе  
**И:** Метрики cortex_* доступны в интерфейсе  
**И:** Все компоненты отображаются на странице Target со статусом "UP"

### Сценарий: Prometheus автоматически обнаруживает новые хосты
**Дано:** Настроенный Prometheus с file_sd_configs  
**Когда:** Добавляется новый хост в файл targets/nodes/targets.yml  
**И:** Отправляется сигнал SIGHUP процессу Prometheus  
**Тогда:** Новый хост появляется на странице Target  
**И:** Prometheus начинает собирать метрики с нового хоста

## Функциональность: Интеграция Prometheus с Cortex

### Сценарий: Prometheus отправляет метрики в Cortex
**Дано:** Настроенный Prometheus с конфигурацией remote_write на Cortex  
**Когда:** Prometheus собирает новые метрики  
**Тогда:** Метрики успешно передаются в Cortex Distributor  
**И:** В логах Cortex Distributor видны записи о получении данных  
**И:** Метрики доступны для запроса через Cortex Query Frontend

### Сценарий: Cortex сохраняет метрики в долгосрочное хранилище
**Дано:** Настроенные Cortex Ingester и хранилище объектов (MinIO)  
**Когда:** Проходит время, больше chunk_idle_period  
**Тогда:** Ingester сохраняет блоки данных в хранилище  
**И:** В бакете cortex-blocks появляются новые файлы  
**И:** Store Gateway обнаруживает новые блоки данных

### Сценарий: Cortex сжимает и агрегирует долгосрочные данные
**Дано:** Настроенный Cortex Compactor и хранилище с метриками  
**Когда:** Проходит время, достаточное для запуска процесса компактации  
**Тогда:** Compactor объединяет блоки данных  
**И:** Количество файлов в хранилище оптимизируется  
**И:** В логах Compactor видны сообщения об успешной компактации

## Функциональность: Запросы к метрикам

### Сценарий: Запрос к актуальным метрикам через Prometheus
**Дано:** Настроенный Prometheus с собранными метриками  
**Когда:** Пользователь выполняет запрос PromQL в интерфейсе  
**Тогда:** Результаты запроса успешно возвращаются  
**И:** Время выполнения запроса не превышает 5 секунд  
**И:** Данные корректно визуализируются на графике

### Сценарий: Запрос к историческим метрикам через Cortex
**Дано:** Настроенный Cortex с данными старше периода хранения Prometheus  
**Когда:** Пользователь выполняет запрос PromQL через Cortex Query Frontend  
**Тогда:** Результаты успешно извлекаются из хранилища  
**И:** Исторические данные корректно возвращаются  
**И:** Время выполнения запроса приемлемое для объема данных

### Сценарий: Оптимизация запросов через Query Frontend
**Дано:** Настроенный Cortex Query Frontend с параметрами кэширования  
**Когда:** Пользователь выполняет одинаковые запросы несколько раз  
**Тогда:** Повторные запросы выполняются быстрее  
**И:** В логах Query Frontend видны сообщения о кэшировании  
**И:** Общая нагрузка на систему снижается

## Функциональность: Высокая доступность

### Сценарий: Система продолжает работу при отказе Prometheus
**Дано:** Настроенная система с несколькими экземплярами Prometheus  
**Когда:** Один из экземпляров Prometheus выходит из строя  
**Тогда:** Сбор метрик продолжается через другие экземпляры  
**И:** Метрики продолжают поступать в Cortex  
**И:** Пользователи могут продолжать работу без прерываний

### Сценарий: Система продолжает работу при отказе компонента Cortex
**Дано:** Настроенная система с несколькими репликами компонентов Cortex  
**Когда:** Один из компонентов Cortex (например, Ingester) выходит из строя  
**Тогда:** Система продолжает функционировать через другие реплики  
**И:** Не происходит потери данных  
**И:** Система автоматически перераспределяет нагрузку

### Сценарий: Система восстанавливается после полного перезапуска
**Дано:** Полностью остановленная система мониторинга  
**Когда:** Все компоненты перезапускаются  
**Тогда:** Система полностью восстанавливает свою работоспособность  
**И:** Все исторические данные остаются доступными  
**И:** Сбор новых метрик возобновляется автоматически

## Функциональность: Масштабируемость

### Сценарий: Горизонтальное масштабирование компонентов Cortex
**Дано:** Работающая система с начальным количеством реплик компонентов  
**Когда:** Увеличивается количество реплик компонентов (Distributor, Ingester)  
**Тогда:** Новые экземпляры успешно запускаются и присоединяются к кластеру  
**И:** Нагрузка равномерно распределяется между всеми экземплярами  
**И:** Производительность системы увеличивается

### Сценарий: Система выдерживает увеличение количества метрик
**Дано:** Работающая система с определенным количеством хостов  
**Когда:** Значительно увеличивается количество мониторируемых хостов  
**Тогда:** Система продолжает стабильно работать  
**И:** Время выполнения запросов остается в приемлемых пределах  
**И:** Компоненты системы автоматически масштабируются при необходимости

### Сценарий: Система выдерживает увеличение количества запросов
**Дано:** Работающая система с настроенным Query Frontend  
**Когда:** Значительно увеличивается количество одновременных запросов  
**Тогда:** Все запросы успешно обрабатываются  
**И:** Время отклика увеличивается незначительно  
**И:** Не происходит отказов в обслуживании

## Функциональность: Алертинг

### Сценарий: Создание алерта при недоступности хоста
**Дано:** Настроенное правило алертинга для метрики up == 0  
**Когда:** Один из хостов становится недоступным  
**Тогда:** Создается алерт "InstanceDown"  
**И:** Алерт отображается в интерфейсе AlertManager  
**И:** Отправляется уведомление по настроенным каналам

### Сценарий: Создание алерта при высокой нагрузке на CPU
**Дано:** Настроенное правило алертинга для высокой нагрузки на CPU  
**Когда:** Нагрузка на CPU превышает пороговое значение в течение заданного времени  
**Тогда:** Создается алерт "HighCpuLoad"  
**И:** Алерт отображается в интерфейсе AlertManager  
**И:** Отправляется уведомление по настроенным каналам

### Сценарий: Группировка и подавление алертов
**Дано:** Настроенные правила группировки и подавления в AlertManager  
**Когда:** Возникает несколько связанных алертов  
**Тогда:** AlertManager группирует алерты согласно настройкам  
**И:** Подавляемые алерты не отправляются как уведомления  
**И:** Пользователь получает консолидированные уведомления

## Функциональность: Визуализация данных

### Сценарий: Настройка базовых дашбордов в Grafana
**Дано:** Установленная Grafana с источниками данных Prometheus и Cortex  
**Когда:** Импортируются преднастроенные дашборды  
**Тогда:** Дашборды успешно загружаются  
**И:** Панели дашбордов корректно отображают данные  
**И:** Все графики и метрики обновляются в реальном времени

### Сценарий: Настройка пользовательских дашбордов
**Дано:** Установленная Grafana с источниками данных  
**Когда:** Пользователь создает новый дашборд  
**И:** Добавляет на него панели с запросами PromQL  
**Тогда:** Дашборд успешно сохраняется  
**И:** Панели корректно отображают данные согласно запросам  
**И:** Дашборд доступен всем пользователям с соответствующими правами

### Сценарий: Настройка алертов в Grafana
**Дано:** Установленная Grafana с источниками данных  
**Когда:** Пользователь настраивает алерт для панели дашборда  
**Тогда:** Алерт успешно создается  
**И:** При выполнении условия алерта отправляется уведомление  
**И:** Состояние алерта корректно отображается в интерфейсе

## Функциональность: Управление системой

### Сценарий: Добавление новых хостов для мониторинга
**Дано:** Работающая система мониторинга  
**Когда:** Запускается скрипт добавления хостов `add_hosts.sh`  
**И:** Вводятся адреса новых хостов  
**Тогда:** Хосты добавляются в конфигурацию  
**И:** Prometheus начинает собирать метрики с новых хостов  
**И:** Новые хосты отображаются на дашбордах Grafana

### Сценарий: Обновление компонентов системы
**Дано:** Работающая система мониторинга  
**Когда:** Запускается процедура обновления (docker-compose pull и up или kubectl apply)  
**Тогда:** Компоненты обновляются до новых версий  
**И:** Система продолжает работать без потери данных  
**И:** Все конфигурации сохраняются после обновления

### Сценарий: Резервное копирование и восстановление конфигурации
**Дано:** Работающая система мониторинга  
**Когда:** Выполняется резервное копирование конфигурации  
**И:** Затем выполняется восстановление из резервной копии  
**Тогда:** Все настройки успешно восстанавливаются  
**И:** Система продолжает работать с восстановленной конфигурацией  
**И:** Не требуется дополнительная настройка компонентов
